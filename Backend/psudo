param stucture

PersonalEvent[
    ------------------------------------------
    | Course_Name: Club                      |
    | Lecture[                               |
    |   ---------------------------------    |
    |   |   Prof_Name: Club             |    |
    |   |   Lecture_Time: (1610,1650)   |    |
    |   |   Lecture_Day: [M]            |    |
    |   ---------------------------------    |
    ------------------------------------------
    ------------------------------------------
    | Course_Name: Baby Sit                  |
    | Lecture[                               |
    |   ---------------------------------    |
    |   |   Event_Name: Baby Sit        |    |
    |   |   Event_Time: (1420,1700)     |    |
    |   |   Event_Day: [Tu,Th]          |    |
    |   ---------------------------------    |
    ------------------------------------------
]

mustHave[
    ------------------------------------------
    | Course_Name: cse110                    |
    | Lecture[                               |
    |   ---------------------------------    |
    |   |   Prof_Name: Gary, Gillespie  |    |
    |   |   Lecture_Time: (1100,1220)   |    |
    |   |   Lecture_Day: [Tu,Th]        |    |
    |   ---------------------------------    |
    | ]                                      |
    ------------------------------------------
    ------------------------------------------
    | Course_Name: cse100                    |
    | Lecture[                               |
    |   ---------------------------------    |
    |   |   Prof_Name: Paul, Cao        |    |
    |   |   Lecture_Time: (900,950)     |    |
    |   |   Lecture_Day: [M,W,F]        |    |
    |   ---------------------------------    |
    |   ---------------------------------    |
    |   |   Prof_Name: Paul, Cao        |    |
    |   |   Lecture_Time: (1000,1050)   |    |
    |   |   Lecture_Day: [M,W,F]        |    |
    |   ---------------------------------    |
    |   ---------------------------------    |
    |   |   Prof_Name: Christine, Alv.. |    |
    |   |   Lecture_Time: (1400,1520)   |    |
    |   |   Lecture_Day: [Tu,Th]        |    |
    |   ---------------------------------    |
    |   ---------------------------------    |
    |   |   Prof_Name: Christine, Alv.. |    |
    |   |   Lecture_Time: (1530, 1650)  |    |
    |   |   Lecture_Day: [Tu,Th]        |    |
    |   ---------------------------------    |
    | ]                                      |
    ------------------------------------------
]

populate( courseName[], dictonary ) {
    // get sections from dictoranary

    lecture[];             // array of lecture sections to be returned
    final[];
    discussion[];
    Lab[];

    for ( cName : courseName ) {
        courseDict = queryDBCourse( cName );

        for section in courseDict{
            if (section.instructionType == "LE") {
                Section s1 = new Section( cName,
                                          section.sectionId,
                                          section.instructionType,
                                          [],
                                          0,
                                          0);
                for rs in section.recurringMeeting {
                    s1.instructionDay.append(rs.dayCode);
                    s1.startTime = rs.startTime;
                    s1.endTime = rs.endTime;
                }
            }
            if (section.instructionType == "LE" && section.additionalMeetings.meetingType == "FI" ) {
                Section s1 = new Section( cName,
                                          section.additionalMeetings.meetingType;
                                          section.additionalMeetings.
                                          [],
                                          0,
                                          0);
                for rs in section.recurringMeeting {
                    s1.instructionDay.append(rs.dayCode);
                    s1.startTime = rs.startTime;
                    s1.endTime = rs.endTime;
                }
            }
            if (section.instructionType == "DI") {
                Section s1 = new Section( cName,
                                          section.sectionId,
                                          section.instructionType,
                                          [],
                                          0,
                                          0);
                for rs in section.recurringMeeting {
                    s1.instructionDay.append(rs.dayCode);
                    s1.startTime = rs.startTime;
                    s1.endTime = rs.endTime;
                }
            }
            if (section.instructionType == "LA") {
                Section s1 = new Section( cName,
                                          section.sectionId,
                                          section.instructionType,
                                          [],
                                          0,
                                          0);
                for rs in section.recurringMeeting {
                    s1.instructionDay.append(rs.dayCode);
                    s1.startTime = rs.startTime;
                    s1.endTime = rs.endTime;
                }
            }
        }
    }

    return [lecture, final, discussion, lab]; //array of 4 elements
}

/*
 * Main Method
 * personalEvent[] should be an array of section where each section is an event
 */
generateSchedule( personalEvent[], mustHave[], wantToHave[], dictionary ) {

    Class Section {
        str courseName;
        int sectionID;
        str instructionType;
        str instructionDay[];
        int startTime;
        int endTime;
    };

    Class Node {
        Section node;
        Section children[];

    }

    Class Graph {
        int size = 0;
        Node vertices[];
        approvedClasses[];
        
        /* class Function */
        add( Section s) {
            vertices.append( New Node(s, []) );
            for v in vertices {
                if (s.startTime > v.endTime) {
                    v.children.append( s );
                }
            }
        }
    }

    sectionArr[] = populate( mustHave[], dictonary );
    lecture[] = sectionArr[0];
    final[] = sectionArr[1];
    discussion[] = sectionArr[2];
    lab[] = sectionArr[3];

    pe_final_arr = personalEvent.append(final)         // create a new array that is PE + FI
    sort( pe_final_arr, key.StartTime );

    approveFinal[];
    for evnt in pe_final_arr {                         // removing all final that intersect with PE
        if (approveFinal.size == 0) {
            tapproveFinal.append(evnt);
        }
        if( approveFinal[approveFinal.size()].instructionType == "PE" && evnt.starTime > approveFinal[approveFinal.size()].endTime ) { // add only if new event does not conflict with PE
            approveFinal.append(evnt);
        } else if( evnt.instructionType == "PE" && evnt.starTime <= approveFinal[approveFinal.size()].endTime ) { // if event conflict with PE then remove it and replace it with PE
            approveFinal.removeLast();
            approveFinal.append(evnt);
        } else if( evnt.instructionType == "PE" && evnt.starTime > approveFinal[approveFinal.size()].endTime ) { // add if there are no conflict with PE
            approveFinal.append(evnt);
        } else if( evnt.instructionType != "PE" && approveFinal.[approveFinal.Size()].instructionType != "PE") {
            approveFinal.append(evnt);
        }
    }


    // approveFinal contain a list of final and PE, where PE and FI does not intersect.
    // courseName in approveFinal are courses can take.
    approvedFinal[] = approveFinal;
    str canTake[];
    for c in approveFinal {
        if( c.instructionType == "FI" ){
            if( canTake.find( c.courseName) == 0 ){
                canTake.append( c.courseName );
            }
        }
    }


    // out of MustTake only consider classes that we can attend final
    sectionArr[] = populate( canTake[], dictonary );
    lecture[] = sectionArr[0];
    final[] = sectionArr[1];
    discussion[] = sectionArr[2];
    lab[] = sectionArr[3];

    pe_le_arr = personalEvent.append(lecture)         // create a new array that is PE + Lecture
    sort( pe_le_arr, key.StartTime );

    approvedLecture[];
    for evnt in pe_le_arr {
        if (approvedLecture.size == 0) {
            approvedLecture.append(evnt);
        }
        if( approvedLecture[approvedLecture.size()].instructionType == "PE" && evnt.starTime > approvedLecture[approvedLecture.size()].endTime ) { // add only if new event does not conflict with PE
            approvedLecture.append(evnt);
        } else if( evnt.instructionType == "PE" && evnt.starTime <= approvedLecture[approvedLecture.size()].endTime ) { // if event conflict with PE then remove it and replace it with PE
            approvedLecture.removeLast();
            approvedLecture.append(evnt);
        } else if( evnt.instructionType == "PE" && evnt.starTime > approvedLecture[approvedLecture.size()].endTime ) { // add if there are no conflict with PE
            approvedLecture.append(evnt);
        } else if( evnt.instructionType != "PE" && approvedLecture.[approvedLecture.size()].instructionType != "PE") {
            approvedLecture.append(evnt);
        }
    }

    str canTakeLecture[];
    for c in approvedLecture {
        if( c.instructionType == "LE" ){
            if( canTake.find( c.courseName) == 0 ){
                canTake.append( c.courseName );
            }
        }
    }

    // for FI Section in approved final
    //      
    // 

    Class Approved {
        str courseName;
        int lectureID;
        int finalID;
    }
    
    for final in approvedFinal
}
